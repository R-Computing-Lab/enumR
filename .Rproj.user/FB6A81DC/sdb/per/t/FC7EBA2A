{
    "collab_server" : "",
    "contents" : "#' @title enumR function\n#'\n#' @description The enumR function is a heavily modified version of the \\code{vss} function from \\code{Psych} Package]. Both functions are designed to help researchers determine the number of factors in their exploratory factor analysis. This function includes a variarity of methods.\n#'\n#'\n#' @param cor\tWhat kind of correlation to find, defaults to covariance matrix, but see fa for the choices\n#' @param diagonal\tShould we fit the diagonal as well\n#' @param method\t factoring method â€“ fm=\"pa\" Principal Axis Factor Analysis, fm = \"minres\" minimum residual (OLS) factoring fm=\"ml\" Maximum Likelihood FA, fm=\"pc\" Principal Components\"\n#' @param samplesize\t Number of observations if doing a factor analysis of correlation matrix. This value is ignored by VSS but is necessary for the ML factor analysis packag\n#' @param nfactors Maximum number of factors to extract. Needs to be larger than expected.\n#' @param rotation what rotation to use c(\"none\", \"varimax\", \"oblimin\",\"promax\")\n#' @param true_model If TRUE, Estimates model using \\code{nfactors} only. Is used in \\code{enumRsimulation} function. Default is FALSE.\n#' @param use\tIf doing covariances or Pearson R, should we use \"pairwise\" or \"complete cases\"\n#' @param x a correlation matrix or a data matrix\n#' ...\tparameters to pass to the factor analysis program The most important of these is if using a correlation matrix is covmat= xx\n#' @return dataframe\n\n\nenumR<-function(x, nfactors = 8, rotation = \"oblimin\", diagonal = FALSE, method = \"ml\",samplesize=NULL,use=\"pairwise\",cor=\"cov\",truemodel=FALSE,...){\n  require(psych)\n  require(GAIPE)\n  n=nfactors; fm=method\n # cl <- match.call()\n  if (rotation == \"oblimin\") {\n    if (!requireNamespace(\"GPArotation\")) {\n      stop(\"You must have GPArotation installed to use oblimin rotation\")\n    }\n  }\n\n  old_rotation = rotation\n\n  if(truemodel){\n    complexrow <- function(x, c) {\n      n = length(x)\n      temp <- x\n      x <- rep(0, n)\n      for (j in 1:c) {\n        locmax <- which.max(abs(temp))\n        x[locmax] <- sign(temp[locmax]) * max(abs(temp))\n        temp[locmax] <- 0\n      }\n      return(x)\n    }\n    complexmat <- function(x, c) {\n      nrows <- dim(x)[1]\n      ncols <- dim(x)[2]\n      for (i in 1:nrows) {\n        x[i, ] <- complexrow(x[i, ], c)\n      }\n      return(x)\n    }\n    map <- function(x, n) {\n      nvar <- dim(x)[2]\n      min.partial <- rep(NA, n)\n      e <- eigen(x)\n      evect <- e$vectors\n      comp <- evect %*% diag(sqrt(e$values))\n      if (n >= nvar) {\n        n1 <- nvar - 1\n      } else {\n        n1 <- n\n      }\n\n        c11.star <- x - comp[, 1:n1] %*% t(comp[, 1:n1])\n        d <- diag(1/sqrt(diag(c11.star)))\n        rstar <- d %*% c11.star %*% d\n        diag(rstar) <- 0\n        min.partial <- sum(rstar * rstar)/(nvar * (nvar -1))\n\n      return(min.partial)\n    }\n    if (dim(x)[2] < n)\n      n <- dim(x)[2]\n    complexfit <- array(0, dim = c(1, 1))\n    complexresid <- array(0, dim = c(1, 1))\n    vss.df <- data.frame(dof = 0, chisq = NA, prob = NA,sqresid = NA, fit = NA, RMSEA = NA,RMSEA_lower=NA,RMSEA_upper=NA, BIC = NA, SABIC = NA, null.model = NA, null.dof = NA, null.chisq = NA,complex = NA, eChisq = NA, SRMR = NA, eCRMS = NA, eBIC = NA, TLI=NA,fa.fit=NA,fa.fit.off=NA, objective=NA,ENull=NA,eSABIC=NA,null.chisq1=NA,TLI.m=NA, NFI.m=NA, CFI.m=NA,RMSEA_lower.m=NA,RMSEA_upper.m=NA)\n\n    if (!is.matrix(x))\n      x <- as.matrix(x)\n\n    if (is.null(samplesize)) {\n      message(\"samplesize was not specified and was arbitrarily set to 1000.  This only affects the chi square values.\")\n      samplesize <- 1000}\n\n    map.values <- map(x, n)\n    if (n > dim(x)[2]) {\n      n <- dim(x)[2]}\n\n\n      PHI <- diag(n)\n      if (n < 2) {\n        (rotation = \"none\")\n      }\n      else {\n        rotation = old_rotation\n      }\n\n      f <- fa(x, n, rotate = rotation, n.obs = samplesize, warnings = FALSE,\n              fm = fm, scores = \"none\", cor = cor, ...)\n\n        original <- x\n        sqoriginal <- original * original\n        totaloriginal <- sum(sqoriginal) - diagonal *\n          sum(diag(sqoriginal))\n\n\n      load <- as.matrix(f$loadings)\n      model <- load %*% PHI %*% t(load)\n      residual <- original - model\n      sqresid <- residual * residual\n      totalresid <- sum(sqresid) - diagonal * sum(diag(sqresid))\n      fit <- 1 - totalresid/totaloriginal\n\n      vss.df[ \"dof\"] <- f$dof\n      vss.df[ \"chisq\"] <- f$STATISTIC\n      vss.df[ \"prob\"] <- f$PVAL\n      vss.df[\"eChisq\"] <- f$chi\n      vss.df[\"ENull\"] <- f$ENull\n      vss.df[\"SRMR\"] <- f$rms\n      vss.df[\"eRMS\"] <- f$rms\n      vss.df[\"eCRMS\"] <- f$crms\n      vss.df[\"eBIC\"] <- f$EBIC\n      vss.df[\"eSABIC\"] <- f$ESABIC\n\n      vss.df[\"TLI\"]<-f$TLI\n      vss.df[\"TLI.m\"]<-(f$null.chisq/f$null.dof - f$STATISTIC/f$dof)/(f$null.chisq/f$null.dof - 1)\n\n      vss.df[\"NFI.m\"]<-(f$null.chisq - f$STATISTIC)/(f$null.chisq)\n\n      vss.df[\"CFI.m\"]<-(f$null.chisq-f$null.dof - f$STATISTIC-f$dof)/(f$null.chisq-f$null.dof)\n\n      vss.df[\"CFI.m\"]<-(f$null.chisq-f$null.dof - f$STATISTIC-f$dof)/(f$null.chisq-f$null.dof)\n\n      vss.df[\"null.model\"] = f$null.model\n      vss.df[\"null.dof\"] = f$null.dof\n\n      vss.df[\"fa.fit\"] = f$fit\n      vss.df[\"fa.fit.off\"] = f$fit.off\n      vss.df[\"objective\"] = f$objective\n      if (!is.null(f$chisq)) {\n        vss.df[\"null.chisq1\"] = f$chisq\n        vss.df[\"null.chisq\"] = f$null.chisq\n      }\n      if (!is.null(f$RMSEA[1])) {\n        vss.df[ \"RMSEA\"] <- f$RMSEA[1]\n        vss.df[ \"RMSEA_upper\"] <- f$RMSEA[3]\n        vss.df[ \"RMSEA_lower\"] <- f$RMSEA[2]\n\n        RMSEA.m<-CI.RMSEA(f$RMSEA[1],N=samplesize,df=f$dof,clevel=1-f$RMSEA[4])\n\n        vss.df[ \"RMSEA_upper.m\"] <- RMSEA.m$Upper.CI\n        vss.df[ \"RMSEA_lower.m\"] <- RMSEA.m$Lower.CI\n\n      }\n      else {\n        vss.df[ \"RMSEA\"] <- NA\n      }\n\n      if (!is.null(f$BIC)) {\n        vss.df[ \"BIC\"] <- f$BIC\n      }\n      else {\n        vss.df[ \"BIC\"] <- NA\n      }\n      if (!is.null(f$SABIC)) {\n        vss.df[ \"SABIC\"] <- f$SABIC\n      }\n      else {\n        vss.df[ \"SABIC\"] <- NA\n      }\n      if (!is.null(f$complexity)) {\n        vss.df[ \"complex\"] <- mean(f$complexity)\n      }\n      else {\n        vss.df[ \"complex\"] <- NA\n      }\n\n      vss.df[ \"sqresid\"] <- totalresid\n      vss.df[ \"fit\"] <- fit\n      for (c in 1:n) {\n        simpleload <- complexmat(load, c)\n        model <- simpleload %*% PHI %*% t(simpleload)\n        residual <- original - model\n        sqresid <- residual * residual\n        totalsimple <- sum(sqresid) - diagonal * sum(diag(sqresid))\n        simplefit <- 1 - totalsimple/totaloriginal\n        complexresid[c] <- totalsimple\n        complexfit[c] <- simplefit\n      }\n\n  }else{\n  complexrow <- function(x, c) {\n    n = length(x)\n    temp <- x\n    x <- rep(0, n)\n    for (j in 1:c) {\n      locmax <- which.max(abs(temp))\n      x[locmax] <- sign(temp[locmax]) * max(abs(temp))\n      temp[locmax] <- 0\n    }\n    return(x)\n  }\n  complexmat <- function(x, c) {\n    nrows <- dim(x)[1]\n    ncols <- dim(x)[2]\n    for (i in 1:nrows) {\n      x[i, ] <- complexrow(x[i, ], c)\n    }\n    return(x)\n  }\n  map <- function(x, n) {\n    nvar <- dim(x)[2]\n    min.partial <- rep(NA, n)\n    e <- eigen(x)\n    evect <- e$vectors\n    comp <- evect %*% diag(sqrt(e$values))\n    if (n >= nvar) {\n      n1 <- nvar - 1\n    } else {\n      n1 <- n\n    }\n    for (i in 1:n1) {\n      c11.star <- x - comp[, 1:i] %*% t(comp[, 1:i])\n      d <- diag(1/sqrt(diag(c11.star)))\n      rstar <- d %*% c11.star %*% d\n      diag(rstar) <- 0\n      min.partial[i] <- sum(rstar * rstar)/(nvar * (nvar -1))\n    }\n    return(min.partial)\n  }\n  if (dim(x)[2] < n)\n    n <- dim(x)[2]\n  complexfit <- array(0, dim = c(n, n))\n  complexresid <- array(0, dim = c(n, n))\n  vss.df <- data.frame(dof = rep(0, n), chisq = NA, prob = NA,sqresid = NA, fit = NA, RMSEA = NA,RMSEA_lower=NA,RMSEA_upper=NA, BIC = NA, SABIC = NA, null.model = NA, null.dof = NA, null.chisq = NA,complex = NA, eChisq = NA, SRMR = NA, eCRMS = NA, eBIC = NA, TLI=NA,fa.fit=NA,fa.fit.off=NA, objective=NA,ENull=NA,eSABIC=NA,null.chisq1=NA,TLI.m=NA, NFI.m=NA, CFI.m=NA,RMSEA_lower.m=NA,RMSEA_upper.m=NA)\n\n  if (!is.matrix(x))\n    x <- as.matrix(x)\n\n  if (is.null(samplesize)) {\n    message(\"samplesize was not specified and was arbitrarily set to 1000.  This only affects the chi square values.\")\n    samplesize <- 1000}\n\n  map.values <- map(x, n)\n  if (n > dim(x)[2]) {\n    n <- dim(x)[2]}\n\n  for (i in 1:n) {\n    PHI <- diag(i)\n    if (i < 2) {\n      (rotation = \"none\")\n    }\n    else {\n      rotation = old_rotation\n    }\n\n    f <- fa(x, i, rotate = rotation, n.obs = samplesize, warnings = FALSE,\n            fm = fm, scores = \"none\", cor = cor, ...)\n    if (i == 1) {\n      original <- x\n      sqoriginal <- original * original\n      totaloriginal <- sum(sqoriginal) - diagonal *\n        sum(diag(sqoriginal))\n    }\n\n    load <- as.matrix(f$loadings)\n    model <- load %*% PHI %*% t(load)\n    residual <- original - model\n    sqresid <- residual * residual\n    totalresid <- sum(sqresid) - diagonal * sum(diag(sqresid))\n    fit <- 1 - totalresid/totaloriginal\n\n    vss.df[i, \"dof\"] <- f$dof\n    vss.df[i, \"chisq\"] <- f$STATISTIC\n    vss.df[i, \"prob\"] <- f$PVAL\n    vss.df[i, \"eChisq\"] <- f$chi\n    vss.df[i, \"ENull\"] <- f$ENull\n    vss.df[i, \"SRMR\"] <- f$rms\n    vss.df[i, \"eRMS\"] <- f$rms\n    vss.df[i, \"eCRMS\"] <- f$crms\n    vss.df[i, \"eBIC\"] <- f$EBIC\n    vss.df[i, \"eSABIC\"] <- f$ESABIC\n\n    vss.df[i,\"TLI\"]<-f$TLI\n    vss.df[i,\"TLI.m\"]<-(f$null.chisq/f$null.dof - f$STATISTIC/f$dof)/(f$null.chisq/f$null.dof - 1)\n\n    vss.df[i,\"NFI.m\"]<-(f$null.chisq - f$STATISTIC)/(f$null.chisq)\n\n    vss.df[i,\"CFI.m\"]<-(f$null.chisq-f$null.dof - f$STATISTIC-f$dof)/(f$null.chisq-f$null.dof)\n\n    vss.df[i,\"CFI.m\"]<-(f$null.chisq-f$null.dof - f$STATISTIC-f$dof)/(f$null.chisq-f$null.dof)\n\n    vss.df[i,\"null.model\"] = f$null.model\n    vss.df[i,\"null.dof\"] = f$null.dof\n\n    vss.df[i,\"fa.fit\"] = f$fit\n    vss.df[i,\"fa.fit.off\"] = f$fit.off\n    vss.df[i,\"objective\"] = f$objective\n    if (!is.null(f$chisq)) {\n      vss.df[i,\"null.chisq1\"] = f$chisq\n      vss.df[i,\"null.chisq\"] = f$null.chisq\n    }\n    if (!is.null(f$RMSEA[1])) {\n      vss.df[i, \"RMSEA\"] <- f$RMSEA[1]\n      vss.df[i, \"RMSEA_upper\"] <- f$RMSEA[3]\n      vss.df[i, \"RMSEA_lower\"] <- f$RMSEA[2]\n\n      RMSEA.m<-CI.RMSEA(f$RMSEA[1],N=samplesize,df=f$dof,clevel=1-f$RMSEA[4])\n\n      vss.df[i, \"RMSEA_upper.m\"] <- RMSEA.m$Upper.CI\n      vss.df[i, \"RMSEA_lower.m\"] <- RMSEA.m$Lower.CI\n\n    }\n    else {\n      vss.df[i, \"RMSEA\"] <- NA\n    }\n\n    if (!is.null(f$BIC)) {\n      vss.df[i, \"BIC\"] <- f$BIC\n    }\n    else {\n      vss.df[i, \"BIC\"] <- NA\n    }\n    if (!is.null(f$SABIC)) {\n      vss.df[i, \"SABIC\"] <- f$SABIC\n    }\n    else {\n      vss.df[i, \"SABIC\"] <- NA\n    }\n    if (!is.null(f$complexity)) {\n      vss.df[i, \"complex\"] <- mean(f$complexity)\n    }\n    else {\n      vss.df[i, \"complex\"] <- NA\n    }\n\n    vss.df[i, \"sqresid\"] <- totalresid\n    vss.df[i, \"fit\"] <- fit\n    for (c in 1:i) {\n      simpleload <- complexmat(load, c)\n      model <- simpleload %*% PHI %*% t(simpleload)\n      residual <- original - model\n      sqresid <- residual * residual\n      totalsimple <- sum(sqresid) - diagonal * sum(diag(sqresid))\n      simplefit <- 1 - totalsimple/totaloriginal\n      complexresid[i, c] <- totalsimple\n      complexfit[i, c] <- simplefit\n    }\n  }\n  }\n  vss.stats <- data.frame(vss.df, cfit = complexfit, cresidual = complexresid,map.values)\n\n  #class(vss.results) <- c(\"psych\", \"vss\")\n  if(truemodel){\n  return(vss.stats[1,])\n    }else{return(vss.stats)}\n  #return(f)\n}\n",
    "created" : 1497244032924.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1413964865",
    "id" : "FC7EBA2A",
    "lastKnownWriteTime" : 1497368183,
    "last_content_update" : 1497368183233,
    "path" : "E:/Dropbox/Lab/Research/Projects/Current/enumR/R/enumR.R",
    "project_path" : "R/enumR.R",
    "properties" : {
        "source_window_id" : ""
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}